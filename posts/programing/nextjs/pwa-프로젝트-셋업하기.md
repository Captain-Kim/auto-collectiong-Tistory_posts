<h2 data-ke-size="size26">패키지 설치</h2>
<pre id="code_1721063119376" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>yarn add next-pwa
yarn add -D webpack</code></pre>
<h2 data-ke-size="size26">next.config.mjs 설정</h2>
<pre id="code_1721063132878" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>import withPWAInit from "next-pwa";
<p>const withPWA = withPWAInit({
dest: &quot;public&quot;,
});</p>
<p>/** @type {import('next').NextConfig} */
const nextConfig = {};</p>
<p>export default withPWA(nextConfig);</code></pre></p>
<h2 data-ke-size="size26">public/manifest.json 설정</h2>
<pre id="code_1721063149280" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>{
    "name": "My Next.js PWA",
    "short_name": "NextPWA",
    "description": "My awesome Next.js PWA!",
    "icons": [
        {
            "src": "/test_icon.png",
            "type": "image/png",
            "sizes": "192x192"
        },
        {
            "src": "/test_icon.png",
            "type": "image/png",
            "sizes": "512x512"
        }
    ],
    "start_url": "/",
    "background_color": "#ffffff",
    "theme_color": "#000000",
    "display": "standalone"
}</code></pre>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>아이콘은 사이즈별로 준비해야 함. 위 예제처럼 하면 안 됨. (안 될 건 없지만 의도한 대로 작동 안 할 수 있음.)</li>
<li>더불어 public 폴더에 png 아이콘을 사이즈별로 준비한다.</li>
<li>이 외에도 다양한 환경에 대응하고 싶다면 객체를 추가해서 사이즈 별로 대응 가능.</li>
</ul>
<h2 data-ke-size="size26">app/layout.tsx 설정</h2>
<pre id="code_1721063193778" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>import Footer from "@/components/public/Footer";
import Header from "@/components/public/Header";
import type { Metadata, Viewport } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
<p>const inter = Inter({ subsets: [&quot;latin&quot;] });</p>
<p>// 이 부분
export const viewport: Viewport = {
themeColor: &quot;black&quot;,
width: &quot;device-width&quot;,
initialScale: 1,
maximumScale: 1,
userScalable: false,
viewportFit: &quot;cover&quot;,
};</p>
<p>export const metadata: Metadata = {
title: &quot;Create Next App&quot;,
description: &quot;Generated by create next app&quot;,
manifest: &quot;/manifest.json&quot;,
icons: {
icon: &quot;/test_icon.png&quot;,
shortcut: &quot;/test_icon.png&quot;,
apple: &quot;/test_icon.png&quot;,
other: {
rel: &quot;apple-touch-icon-precomposed&quot;,
url: &quot;/test_icon.png&quot;,
},
},
};
// 이 부분</p>
<p>export default function RootLayout({
children,
}: Readonly&lt;{
children: React.ReactNode;
}&gt;) {
return (
&lt;html lang=&quot;en&quot;&gt;
&lt;body className={inter.className}&gt;
&lt;Header /&gt;
{children}
&lt;Footer /&gt;
&lt;/body&gt;
&lt;/html&gt;
);
}</code></pre></p>
<p data-ke-size="size16">이곳의 메타데이터 타이틀은 앱 이름임.</p>
<h2 data-ke-size="size26">public/sw.js</h2>
<pre id="code_1721063279326" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
<p>clientsClaim();</p>
<p>// self.__WB_MANIFEST is injected by workbox-build during the build process
precacheAndRoute(self.__WB_MANIFEST || []);</p>
<p>// Cache CSS, JS, and web worker requests with a network-first strategy.
registerRoute(
({ request }) =&gt; request.destination === 'style' || request.destination === 'script' || request.destination === 'worker',
new NetworkFirst({
cacheName: 'static-resources',
})
);</p>
<p>// Cache image files with a cache-first strategy.
registerRoute(
({ request }) =&gt; request.destination === 'image',
new CacheFirst({
cacheName: 'images',
plugins: [
new ExpirationPlugin({
maxEntries: 50,
}),
],
})
);</p>
<p>// Cache API calls with a network-first strategy.
registerRoute(
({ url }) =&gt; url.pathname.startsWith('/api/'),
new NetworkFirst({
cacheName: 'api',
networkTimeoutSeconds: 10,
plugins: [
new CacheableResponsePlugin({
statuses: [0, 200],
}),
],
})
);</p>
<p>// Cache the start URL with a network-first strategy.
registerRoute(
'/',
new NetworkFirst({
cacheName: 'start-url',
plugins: [
{
cacheWillUpdate: async ({ request, response }) =&gt; {
if (response &amp;&amp; response.type === 'opaqueredirect') {
return new Response(response.body, {
status: 200,
statusText: 'OK',
headers: response.headers,
});
}
return response;
},
},
],
})
);</p>
<p>// Cache everything else with a network-only strategy.
registerRoute(
({ request }) =&gt; true,
new CacheFirst({
cacheName: 'catch-all',
})
);</code></pre></p>
<p data-ke-size="size16">이 파일은 자동으로 셋업 되지만, 빌드 시 인코딩 되어 다음부터 개발 서버를 돌리면 제대로 동작하지 않을 수 있음. 그럴 때는 이 파일을 계속 스니펫처럼 복-붙해야 할 수 있으니 올려 둠.</p>
<h2 data-ke-size="size26">(필요 시) PWA 접속 유무 점검하는 유틸 함수 작성</h2>
<pre id="code_1721063404457" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>// utils/pwa/isPWA.ts (자유)
<p>export const isPWA = (): boolean =&gt; {
return (
window.matchMedia(&quot;(display-mode: standalone)&quot;).matches ||
(window.navigator as any).standalone === true
);
};</code></pre></p>
<h2 data-ke-size="size26">(필요 시) PWA 접속 유무 점검하는 커스텀 훅 작성</h2>
<pre id="code_1721063442467" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>// hooks/useCheckPwa.ts (자유)
<p>import { useEffect, useState } from 'react';</p>
<p>const useCheckPwa = (): boolean =&gt; {
const [isPwa, setIsPwa] = useState(false);</p>
<p>useEffect(() =&gt; {
const checkPwa = (): boolean =&gt; {
return window.matchMedia('(display-mode: standalone)').matches || (window.navigator as any).standalone === true;
};
setIsPwa(checkPwa());
}, []);</p>
<p>return isPwa;
};</p>
<p>export default useCheckPwa;</code></pre></p>
<p data-ke-size="size16">&nbsp;</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>이렇게 만들어진 훅을 import해서 상태의 값에 따라 추가 로직을 작성하면 됨.</li>
<li>단 한계는 useEffect 훅으로 작성되었기 때문에 화면이 그려지고 나서 로직이 작동하기에 화면에서 한 번 깜빡임이 있을 수 있음. 보완이 필요한 추가 로직임.</li>
</ul>